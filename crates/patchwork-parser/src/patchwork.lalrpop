// Patchwork grammar - Milestone 2: Top-level items and block structure

use crate::token::ParserToken;
use crate::adapter::ParseError;
use crate::ast::*;

grammar<'input>(input: &'input str);

// External token definition - we use our custom lexer
extern {
    type Location = usize;
    type Error = ParseError;

    enum ParserToken<'input> {
        // Whitespace
        whitespace => ParserToken::Whitespace(<&'input str>),
        newline => ParserToken::Newline(<&'input str>),

        // String literals
        string_start => ParserToken::StringStart,
        string_end => ParserToken::StringEnd,
        string_text => ParserToken::StringText(<&'input str>),
        single_quote_string => ParserToken::SingleQuoteString(<&'input str>),
        dollar => ParserToken::Dollar,

        // Prompt operators
        "think" => ParserToken::Think,
        "ask" => ParserToken::Ask,
        "do" => ParserToken::Do,

        // Keywords
        "import" => ParserToken::Import,
        "export" => ParserToken::Export,
        "from" => ParserToken::From,
        "var" => ParserToken::Var,
        "if" => ParserToken::If,
        "else" => ParserToken::Else,
        "for" => ParserToken::For,
        "while" => ParserToken::While,
        "await" => ParserToken::Await,
        "agent" => ParserToken::Agent,
        "trait" => ParserToken::Trait,
        "skill" => ParserToken::Skill,
        "fun" => ParserToken::Fun,
        "default" => ParserToken::Default,
        "type" => ParserToken::Type,
        "return" => ParserToken::Return,
        "succeed" => ParserToken::Succeed,
        "fail" => ParserToken::Fail,
        "break" => ParserToken::Break,
        "self" => ParserToken::SelfKw,
        "in" => ParserToken::In,

        // Literals
        "true" => ParserToken::True,
        "false" => ParserToken::False,
        number => ParserToken::Number(<&'input str>),
        identifier => ParserToken::Identifier(<&'input str>),

        // Multi-character operators
        "..." => ParserToken::Ellipsis,
        "->" => ParserToken::Arrow,
        "==" => ParserToken::Eq,
        "!=" => ParserToken::Neq,
        "<=" => ParserToken::Lte,
        ">=" => ParserToken::Gte,
        "&&" => ParserToken::AndAnd,
        "||" => ParserToken::OrOr,
        "++" => ParserToken::PlusPlus,
        "--" => ParserToken::MinusMinus,

        // Punctuation
        "{" => ParserToken::LBrace,
        "}" => ParserToken::RBrace,
        "(" => ParserToken::LParen,
        ")" => ParserToken::RParen,
        "[" => ParserToken::LBracket,
        "]" => ParserToken::RBracket,
        ";" => ParserToken::Semicolon,
        "," => ParserToken::Comma,
        ":" => ParserToken::Colon,
        "@" => ParserToken::At,

        // Single-character operators
        "<" => ParserToken::Lt,
        ">" => ParserToken::Gt,
        "+" => ParserToken::Plus,
        "-" => ParserToken::Minus,
        "*" => ParserToken::Star,
        "/" => ParserToken::Slash,
        "%" => ParserToken::Percent,
        "!" => ParserToken::Bang,
        "?" => ParserToken::Question,
        "=" => ParserToken::Assign,
        "|" => ParserToken::Pipe,
        "&" => ParserToken::Ampersand,
        "." => ParserToken::Dot,

        // Prompt text
        prompt_text => ParserToken::PromptText(<&'input str>),
        prompt_escape => ParserToken::PromptEscape(<&'input str>),

        // Comments
        comment => ParserToken::Comment(<&'input str>),

        // Shell mode tokens (Milestone 10)
        shell_arg => ParserToken::ShellArg(<&'input str>),
        shell_redirect_out => ParserToken::ShellRedirectOut,
        shell_redirect_append => ParserToken::ShellRedirectAppend,
        shell_redirect_in => ParserToken::ShellRedirectIn,
        shell_redirect_err => ParserToken::ShellRedirectErr,
        shell_redirect_err_to_out => ParserToken::ShellRedirectErrToOut,
        shell_pipe => ParserToken::ShellPipe,
        shell_and => ParserToken::ShellAnd,
        shell_or => ParserToken::ShellOr,
        shell_background => ParserToken::ShellBackground,
        shell_assign => ParserToken::ShellAssign,
        shell_backslash => ParserToken::ShellBackslash,

        // Special
        end => ParserToken::End,
    }
}

// ====================
// Grammar Rules
// ====================

// Note: IdentifierOrCall helper removed - no longer needed without IdentifierCall token

// Helper: Accept identifier or keywords (for object keys and pattern fields)
// JavaScript/TypeScript allow keywords as unquoted object keys
ObjectKey: &'input str = {
    <identifier> => <>,
    "type" => "type",
    "import" => "import",
    "from" => "from",
    "var" => "var",
    "if" => "if",
    "else" => "else",
    "for" => "for",
    "while" => "while",
    "agent" => "agent",
    "trait" => "trait",
    "skill" => "skill",
    "fun" => "fun",
    "default" => "default",
    "return" => "return",
    "succeed" => "succeed",
    "fail" => "fail",
    "break" => "break",
    "self" => "self",
    "in" => "in",
    "think" => "think",
    "ask" => "ask",
    "do" => "do",
    "true" => "true",
    "false" => "false",
};

// Program: top-level items (with optional newlines between them - similar to StatementList)
pub Program: Program<'input> = {
    newline* <head:Item> <tail:(newline+ <Item>)*> newline* end => {
        let mut items = vec![head];
        items.extend(tail);  // lalrpop flattens (newline+ <Item>) to just Item
        Program { items }
    },
    newline* end => Program { items: vec![] },  // Empty program
};

// Top-level item
Item: Item<'input> = {
    <ImportDecl> => Item::Import(<>),
    <SkillDecl> => Item::Skill(<>),
    <AgentDecl> => Item::Agent(<>),
    <TraitDecl> => Item::Trait(<>),
    <FunctionDecl> => Item::Function(<>),
    <TypeDecl> => Item::Type(<>),
};

// Import declaration: `import path` or `import ./{a, b, c}`
ImportDecl: ImportDecl<'input> = {
    "import" <path:ImportPath> => ImportDecl { path },
};

// Import path
ImportPath: ImportPath<'input> = {
    // Relative multi-import: ./{analyst, narrator, scribe}
    "." "/" "{" <head:identifier> <tail:("," <identifier>)*> "}" => {
        let mut names = vec![head];
        names.extend(tail);
        ImportPath::RelativeMulti(names)
    },
    // Dotted path: std.log or foo.bar.baz
    <head:identifier> <tail:("." <identifier>)+> => {
        let mut parts = vec![head];
        parts.extend(tail);
        ImportPath::Simple(parts)
    },
    // Simple single identifier
    <id:identifier> => ImportPath::Simple(vec![id]),
};

// Skill declaration: skill name(params) { body }
SkillDecl: SkillDecl<'input> = {
    // Accept both "skill test (" and "skill test("
    <is_exported:"export"?> <is_default:"default"?> "skill" <name:identifier> "("? <params:ParamList> ")" <body:Block> => {
        SkillDecl { name, params, body, is_exported: is_exported.is_some(), is_default: is_default.is_some() }
    },
};

// Agent declaration: agent name(params) { body }
AgentDecl: AgentDecl<'input> = {
    // Accept both "agent test (" and "agent test("
    <is_exported:"export"?> <is_default:"default"?> "agent" <name:identifier> "("? <params:ParamList> ")" <body:Block> => {
        AgentDecl { name, params, body, is_exported: is_exported.is_some(), is_default: is_default.is_some() }
    },
};

// Trait declaration: trait name { methods }
TraitDecl: TraitDecl<'input> = {
    <is_exported:"export"?> <is_default:"default"?> "trait" <name:identifier> "{" newline* <head:FunctionDecl> <tail:(newline+ <FunctionDecl>)*> newline* "}" => {
        let mut methods = vec![head];
        methods.extend(tail);
        TraitDecl { name, methods, is_exported: is_exported.is_some(), is_default: is_default.is_some() }
    },
    <is_exported:"export"?> <is_default:"default"?> "trait" <name:identifier> "{" newline* "}" => {
        TraitDecl { name, methods: vec![], is_exported: is_exported.is_some(), is_default: is_default.is_some() }
    },
};

// Function declaration: fun name(params) { body }
FunctionDecl: FunctionDecl<'input> = {
    // Accept both "fun test (" and "fun test("
    <is_exported:"export"?> <is_default:"default"?> "fun" <name:identifier> "("? <params:ParamList> ")" <body:Block> => {
        FunctionDecl { name, params, body, is_exported: is_exported.is_some(), is_default: is_default.is_some() }
    },
};

// Type declaration: type name = TypeExpr
TypeDecl: TypeDeclItem<'input> = {
    "type" <name:identifier> "=" <type_expr:TypeExpr> => {
        TypeDeclItem { name, type_expr }
    },
};

// Parameter list (comma-separated identifiers)
ParamList: Vec<Param<'input>> = {
    // Empty list
    => vec![],
    // Single param
    <head:identifier> => vec![Param { name: head }],
    // Multiple params
    <head:identifier> <tail:("," <identifier>)+> => {
        let mut params = vec![Param { name: head }];
        for name in tail {
            params.push(Param { name });
        }
        params
    },
};

// Block: { statements }
// Statements are separated by newlines or semicolons (Swift-style)
Block: Block<'input> = {
    "{" <statements:StatementList> "}" => Block { statements },
};

// Separator: newline or semicolon (at least one required between statements)
Separator: () = {
    newline => (),
    ";" => (),
};

// Statement list
// Key insight from Swift: newlines (or semicolons) SEPARATE statements.
// This means after "return", if there's a newline, we know return has no value.
// If there's no newline, the expression continues on the same logical line.
StatementList: Vec<Statement<'input>> = {
    // Empty block (allow leading/trailing newlines)
    newline* => vec![],

    // Non-empty: optional leading newlines, then statements separated by newlines/semicolons
    newline* <head:Statement> <tail:(Separator+ <Statement>)*> Separator* => {
        let mut result = vec![head];
        result.extend(tail);
        result
    },
};

// Statement (Milestone 3: simple statements)
// Order matters for ambiguity resolution - more specific rules first
Statement: Statement<'input> = {
    // Control flow with blocks - unambiguous (blocks provide boundaries)
    <IfStmt>,
    <ForStmt>,
    <WhileStmt>,

    // Declarations - handled explicitly
    <VarDeclStmt>,
    <TypeDeclStmt>,

    // Keywords that can't start expressions - unambiguous
    <ReturnStmt>,
    <SucceedStmt>,
    <FailStmt>,
    <BreakStmt>,

    // Shell statement: $ command args (Milestone 10)
    <ShellStmt>,

    // Command or expression statement - factored to avoid conflicts (Milestone 10)
    // This handles both bare commands (mkdir -p dir) and expression statements (x + y)
    <CommandOrExprStmt>,
};

// Variable declaration with pattern support (Milestone 7)
VarDeclStmt: Statement<'input> = {
    // var pattern = expr
    "var" <pattern:Pattern> "=" <init:Expr> => {
        Statement::VarDecl { pattern, init: Some(init) }
    },
    // var pattern (no init)
    "var" <pattern:Pattern> => {
        Statement::VarDecl { pattern, init: None }
    },
};

// Type declaration statement: type name = TypeExpr (Milestone 10)
TypeDeclStmt: Statement<'input> = {
    "type" <name:identifier> "=" <type_expr:TypeExpr> => {
        Statement::TypeDecl { name, type_expr }
    },
};

// If statement (block provides clear termination)
IfStmt: Statement<'input> = {
    "if" <condition:Expr> <then_block:Block> <else_block:("else" <Block>)?> => {
        Statement::If { condition, then_block, else_block }
    },
};

// For loop (block provides clear termination)
ForStmt: Statement<'input> = {
    "for" "var" <var:identifier> "in" <iter:Expr> <body:Block> => {
        Statement::ForIn { var, iter, body }
    },
};

// While loop (block provides clear termination)
WhileStmt: Statement<'input> = {
    "while" "(" <condition:Expr> ")" <body:Block> => {
        Statement::While { condition, body }
    },
};

// Return statement
// To resolve the ambiguity, we need to be explicit about when there's no expression.
// The parser sees "return" and doesn't know if what follows is:
// 1) part of an expression for this return
// 2) the start of the next statement
//
// Solution: Accept that statements in blocks don't need explicit terminators
// because blocks themselves provide boundaries. But we need to restrict what
// can be a statement-level expression vs a return expression.
//
// Simpler: just always try to parse an expression if possible (greedy matching)
// This rule says: ALWAYS try to match "return <Expr>" first due to ordering
ReturnStmt: Statement<'input> = {
    "return" <e:Expr?> => Statement::Return(e),
};

// Succeed/Fail/Break - these are unambiguous keywords
SucceedStmt: Statement<'input> = {
    "succeed" => Statement::Succeed,
};

FailStmt: Statement<'input> = {
    "fail" => Statement::Fail,
};

BreakStmt: Statement<'input> = {
    "break" => Statement::Break,
};

// Shell statement: $ command args (Milestone 10)
// Parses: $ mkdir -p work_dir
ShellStmt: Statement<'input> = {
    dollar <e:ShellExpr> => Statement::Expr(e),
};

// Expression statement (Milestone 10)
// Note: Bare commands without $ prefix removed - all shell commands require explicit prefix
// This simplifies parsing and eliminates IdentifierCall token need
CommandOrExprStmt: Statement<'input> = {
    // Expression statement (includes standalone identifiers, function calls, etc.)
    <Expr> => Statement::Expr(<>),
};

// Type expression (Milestone 8: complete type system)
// Union types have lowest precedence (type1 | type2 | type3)
TypeExpr: TypeExpr<'input> = {
    <UnionTypeExpr>,
};

// Union type: string | int | "literal"
UnionTypeExpr: TypeExpr<'input> = {
    <head:PrimaryTypeExpr> <tail:("|" <PrimaryTypeExpr>)+> => {
        let mut types = vec![head];
        types.extend(tail);
        TypeExpr::Union(types)
    },
    <PrimaryTypeExpr>,
};

// Primary type expressions (atoms)
PrimaryTypeExpr: TypeExpr<'input> = {
    // Simple type name: string, int, etc.
    <identifier> => TypeExpr::Name(<>),

    // String literal type: "success"
    <StringLiteral> => {
        // Extract the literal value from the string literal
        // For now, we assume it's a simple string (no interpolation)
        // In a real implementation, we'd validate this
        if let Some(StringPart::Text(text)) = <>.parts.first() {
            TypeExpr::Literal(text)
        } else {
            // If it's an interpolated string, that's invalid for a literal type
            // For now, treat as empty literal
            TypeExpr::Literal("")
        }
    },

    // Array type: [ElementType]
    "[" <elem_type:TypeExpr> "]" => TypeExpr::Array(Box::new(elem_type)),

    // Object type: { x: string, y: int }
    "{" <fields:TypeFieldList> "}" => TypeExpr::Object(fields),
};

// Type field list (for object types)
// Allow newlines for formatting (similar to other lists)
TypeFieldList: Vec<TypeField<'input>> = {
    // Empty object type (allow newlines)
    newline* => vec![],
    // Single field (with optional surrounding newlines)
    newline* <head:TypeField> newline* => vec![head],
    // Multiple fields (with newlines allowed around commas)
    newline* <head:TypeField> <tail:(newline* "," newline* <TypeField>)+> newline* => {
        let mut fields = vec![head];
        fields.extend(tail);
        fields
    },
};

// Type field: key: TypeExpr (allows keywords as keys)
TypeField: TypeField<'input> = {
    <key:ObjectKey> ":" <type_expr:TypeExpr> => TypeField {
        key,
        type_expr,
        optional: false,  // For now, no optional fields
    },
};

// Pattern for variable declarations (Milestone 7)
Pattern: Pattern<'input> = {
    // Simple identifier with optional type: var x: type = ...
    <name:identifier> <type_ann:(":" <TypeExpr>)?> => Pattern::Identifier { name, type_ann },

    // Object destructuring pattern: var {x, y} = ...
    "{" <fields:ObjectPatternFieldList> "}" => Pattern::Object(fields),
};

// Object pattern field list (allow newlines for formatting)
ObjectPatternFieldList: Vec<ObjectPatternField<'input>> = {
    // Empty object pattern (allow newlines)
    newline* => vec![],
    // Single field (with optional surrounding newlines)
    newline* <head:ObjectPatternField> newline* => vec![head],
    // Multiple fields (with newlines allowed around commas)
    newline* <head:ObjectPatternField> <tail:(newline* "," newline* <ObjectPatternField>)+> newline* => {
        let mut fields = vec![head];
        fields.extend(tail);
        fields
    },
};

// Object pattern field: key, key: type, or key: nestedPattern
ObjectPatternField: ObjectPatternField<'input> = {
    // Simple: {x} means extract x
    <key:ObjectKey> => ObjectPatternField {
        key,
        pattern: Pattern::Identifier { name: key, type_ann: None },
        type_ann: None,
    },
    // With type annotation: {x: string} or {type: string}
    <key:ObjectKey> ":" <type_ann:TypeExpr> => ObjectPatternField {
        key,
        pattern: Pattern::Identifier { name: key, type_ann: None },
        type_ann: Some(type_ann),
    },
};

// Expression with precedence (Milestone 4)
// Manual precedence climbing approach for clarity
// Top-level expression - includes task operator (lowest precedence)
Expr: Expr<'input> = { TaskExpr };

// Task operator: removed - using call syntax instead
TaskExpr: Expr<'input> = { AssignExpr };

// Assignment (right-associative)
AssignExpr: Expr<'input> = {
    <left:PipeExpr> "=" <right:AssignExpr> => Expr::Binary {
        op: BinOp::Assign,
        left: Box::new(left),
        right: Box::new(right),
    },
    PipeExpr,
};

// Pipe operator
PipeExpr: Expr<'input> = {
    <left:PipeExpr> "|" <right:OrExpr> => Expr::Binary {
        op: BinOp::Pipe,
        left: Box::new(left),
        right: Box::new(right),
    },
    OrExpr,
};

// Logical OR
OrExpr: Expr<'input> = {
    <left:OrExpr> "||" <right:AndExpr> => Expr::Binary {
        op: BinOp::Or,
        left: Box::new(left),
        right: Box::new(right),
    },
    AndExpr,
};

// Logical AND
AndExpr: Expr<'input> = {
    <left:AndExpr> "&&" <right:CompExpr> => Expr::Binary {
        op: BinOp::And,
        left: Box::new(left),
        right: Box::new(right),
    },
    CompExpr,
};

// Comparison operators
CompExpr: Expr<'input> = {
    <left:CompExpr> "==" <right:RangeExpr> => Expr::Binary {
        op: BinOp::Eq,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:CompExpr> "!=" <right:RangeExpr> => Expr::Binary {
        op: BinOp::NotEq,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:CompExpr> "<" <right:RangeExpr> => Expr::Binary {
        op: BinOp::Lt,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:CompExpr> ">" <right:RangeExpr> => Expr::Binary {
        op: BinOp::Gt,
        left: Box::new(left),
        right: Box::new(right),
    },
    RangeExpr,
};

// Range operator
RangeExpr: Expr<'input> = {
    <left:RangeExpr> "..." <right:AddExpr> => Expr::Binary {
        op: BinOp::Range,
        left: Box::new(left),
        right: Box::new(right),
    },
    AddExpr,
};

// Addition/Subtraction
AddExpr: Expr<'input> = {
    <left:AddExpr> "+" <right:MulExpr> => Expr::Binary {
        op: BinOp::Add,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:AddExpr> "-" <right:MulExpr> => Expr::Binary {
        op: BinOp::Sub,
        left: Box::new(left),
        right: Box::new(right),
    },
    MulExpr,
};

// Multiplication/Division
MulExpr: Expr<'input> = {
    <left:MulExpr> "*" <right:UnaryExpr> => Expr::Binary {
        op: BinOp::Mul,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:MulExpr> "/" <right:UnaryExpr> => Expr::Binary {
        op: BinOp::Div,
        left: Box::new(left),
        right: Box::new(right),
    },
    UnaryExpr,
};

// Unary operators and await
UnaryExpr: Expr<'input> = {
    "!" <operand:UnaryExpr> => Expr::Unary {
        op: UnOp::Not,
        operand: Box::new(operand),
    },
    "-" <operand:UnaryExpr> => Expr::Unary {
        op: UnOp::Neg,
        operand: Box::new(operand),
    },
    PostfixExpr,
};

// Postfix expressions: member access, call, index
// These are left-associative and have the same precedence
PostfixExpr: Expr<'input> = {
    // Await: expr.await (must come before general member access to avoid ambiguity)
    <operand:PostfixExpr> "." "await" => Expr::Await(Box::new(operand)),

    // Member access: obj.field (allows keywords as field names)
    <object:PostfixExpr> "." <field:ObjectKey> => Expr::Member {
        object: Box::new(object),
        field,
    },

    // Function call: func(args) or obj.method(args)
    // Works for both regular calls and method calls
    <callee:PostfixExpr> "(" <args:ExprList> ")" => Expr::Call {
        callee: Box::new(callee),
        args,
    },

    // Index access: arr[i]
    <object:PostfixExpr> "[" <index:Expr> "]" => Expr::Index {
        object: Box::new(object),
        index: Box::new(index),
    },

    // Postfix increment: x++
    <operand:PostfixExpr> "++" => Expr::PostIncrement(Box::new(operand)),

    // Postfix decrement: x--
    <operand:PostfixExpr> "--" => Expr::PostDecrement(Box::new(operand)),

    // Primary expressions
    <PrimaryExpr>,
};

// Primary expressions (atoms)
PrimaryExpr: Expr<'input> = {
    // Literals
    <identifier> => Expr::Identifier(<>),
    <number> => Expr::Number(<>),
    <StringLiteral> => Expr::String(<>),
    "true" => Expr::True,
    "false" => Expr::False,
    "self" => Expr::Identifier("self"),
    dollar "?" => Expr::Identifier("?"),  // Special shell variable: $?

    // Array literal: [1, 2, 3]
    "[" <elements:ExprList> "]" => Expr::Array(elements),

    // Object literal: {x: 1, y: 2} or {x, y}
    "{" <fields:ObjectFieldList> "}" => Expr::Object(fields),

    // Prompt expressions (think and ask can be used as expressions)
    <ThinkExpr>,
    <AskExpr>,
    // Note: do { } is NOT a standalone expression - only used inside think/ask blocks

    // Shell expressions (Milestone 10)
    // Command substitution: $(shell_expr) → returns stdout as string
    dollar "(" <e:ShellExpr> ")" => Expr::CommandSubst(Box::new(e)),

    // Shell expression: ($ shell_expr) → returns exit code as boolean
    "(" dollar <e:ShellExpr> ")" => e,

    // Parenthesized expression
    "(" <e:Expr> ")" => Expr::Paren(Box::new(e)),
};

// Command arguments - one or more arguments for bare commands
// Continues until hitting a statement terminator or shell operator
CommandArgs: Vec<CommandArg<'input>> = {
    <head:CommandArg> <tail:CommandArg*> => {
        let mut args = vec![head];
        args.extend(tail);
        args
    },
};

// Single command argument - can be a literal token or a string
CommandArg: CommandArg<'input> = {
    // String argument with interpolation: "${work_dir}"
    <s:StringLiteral> => CommandArg::String(s),

    // Variable interpolation in shell mode: $identifier, $shell_arg, or ${expr}
    // In shell mode, after $, we might get shell_arg instead of identifier
    dollar <id:identifier> => {
        // Convert to a string literal with interpolation
        CommandArg::String(StringLiteral {
            parts: vec![StringPart::Interpolation(Box::new(Expr::Identifier(id)))]
        })
    },
    dollar "?" => {
        // Special shell variable: $? (exit code)
        CommandArg::String(StringLiteral {
            parts: vec![StringPart::Interpolation(Box::new(Expr::Identifier("?")))]
        })
    },
    dollar <arg:shell_arg> => {
        // Treat shell_arg after $ as an identifier for interpolation
        CommandArg::String(StringLiteral {
            parts: vec![StringPart::Interpolation(Box::new(Expr::Identifier(arg)))]
        })
    },
    dollar "{" <e:Expr> "}" => {
        // ${expr} interpolation in shell mode
        CommandArg::String(StringLiteral {
            parts: vec![StringPart::Interpolation(Box::new(e))]
        })
    },

    // Shell mode arguments: -p, --flag, file.txt, etc.
    <arg:shell_arg> => CommandArg::Literal(arg),

    // Literal arguments: identifiers and numbers (for backwards compatibility)
    <id:identifier> => CommandArg::Literal(id),
    <num:number> => CommandArg::Literal(num),
};

// Shell expressions with operators (pipes, redirects, logical operators)
// Precedence (lowest to highest): || > && > | > redirects > bare command

// Shell logical or: cmd1 || cmd2
ShellExpr: Expr<'input> = {
    <left:ShellExpr> shell_or <right:ShellAndExpr> => {
        Expr::ShellOr {
            left: Box::new(left),
            right: Box::new(right),
        }
    },
    <ShellAndExpr>,
};

// Shell logical and: cmd1 && cmd2
ShellAndExpr: Expr<'input> = {
    <left:ShellAndExpr> shell_and <right:ShellPipeExpr> => {
        Expr::ShellAnd {
            left: Box::new(left),
            right: Box::new(right),
        }
    },
    <ShellPipeExpr>,
};

// Shell pipe: cmd1 | cmd2
ShellPipeExpr: Expr<'input> = {
    <left:ShellPipeExpr> shell_pipe <right:ShellRedirectExpr> => {
        Expr::ShellPipe {
            left: Box::new(left),
            right: Box::new(right),
        }
    },
    <ShellRedirectExpr>,
};

// Shell redirects: cmd > file, cmd 2> file, etc.
ShellRedirectExpr: Expr<'input> = {
    <cmd:ShellAtom> shell_redirect_out <target:ShellRedirectTarget> => {
        Expr::ShellRedirect {
            command: Box::new(cmd),
            op: RedirectOp::Out,
            target: Box::new(target),
        }
    },
    <cmd:ShellAtom> shell_redirect_append <target:ShellRedirectTarget> => {
        Expr::ShellRedirect {
            command: Box::new(cmd),
            op: RedirectOp::Append,
            target: Box::new(target),
        }
    },
    <cmd:ShellAtom> shell_redirect_in <target:ShellRedirectTarget> => {
        Expr::ShellRedirect {
            command: Box::new(cmd),
            op: RedirectOp::In,
            target: Box::new(target),
        }
    },
    <cmd:ShellAtom> shell_redirect_err <target:ShellRedirectTarget> => {
        Expr::ShellRedirect {
            command: Box::new(cmd),
            op: RedirectOp::ErrOut,
            target: Box::new(target),
        }
    },
    <cmd:ShellAtom> shell_redirect_err_to_out => {
        // 2>&1 doesn't have a target, it's a special redirect
        // For now, treat it as redirecting to a special identifier
        Expr::ShellRedirect {
            command: Box::new(cmd),
            op: RedirectOp::ErrToOut,
            target: Box::new(Expr::Identifier("&1")),
        }
    },
    <ShellAtom>,
};

// Shell redirect target: file path, string, or identifier
ShellRedirectTarget: Expr<'input> = {
    <s:StringLiteral> => Expr::String(s),
    <arg:shell_arg> => Expr::Identifier(arg),
    <id:identifier> => Expr::Identifier(id),
};

// Shell atom: bare command with arguments
ShellAtom: Expr<'input> = {
    <args:CommandArgs> => {
        if let Some(first) = args.first() {
            let name = match first {
                CommandArg::Literal(s) => s,
                CommandArg::String(_) => panic!("Shell command name cannot be a string"),
            };
            Expr::BareCommand {
                name,
                args: args[1..].to_vec()
            }
        } else {
            panic!("Shell command requires at least a command name")
        }
    },
};

// String literal with interpolation support
// Parses: "text", "$id", "${expr}", "$(cmd)", or combinations
StringLiteral: StringLiteral<'input> = {
    string_start <parts:StringPart*> string_end => StringLiteral { parts },
};

// A single part of a string - either text or interpolation
StringPart: StringPart<'input> = {
    // Plain text
    <text:string_text> => StringPart::Text(text),

    // Interpolation: $id form
    dollar <id:identifier> => StringPart::Interpolation(Box::new(Expr::Identifier(id))),

    // Interpolation: ${expr} form
    dollar "{" <e:Expr> "}" => StringPart::Interpolation(Box::new(e)),

    // Interpolation: $(cmd) form - parses as expression
    dollar "(" <e:Expr> ")" => StringPart::Interpolation(Box::new(e)),
};

// Expression list (for function arguments and array literals)
// Allows optional newlines for formatting multi-line argument lists
ExprList: Vec<Expr<'input>> = {
    // Empty list (allow newlines)
    newline* => vec![],
    // Single expr (with optional surrounding newlines)
    newline* <head:Expr> newline* => vec![head],
    // Multiple exprs (with newlines allowed around commas)
    newline* <head:Expr> <tail:(newline* "," newline* <Expr>)+> newline* => {
        let mut exprs = vec![head];
        exprs.extend(tail);
        exprs
    },
};

// Object field list (for object literals - allow newlines for formatting)
ObjectFieldList: Vec<ObjectField<'input>> = {
    // Empty object (allow newlines)
    newline* => vec![],
    // Single field (with optional surrounding newlines)
    newline* <head:ObjectField> newline* => vec![head],
    // Multiple fields (with newlines allowed around commas)
    newline* <head:ObjectField> <tail:(newline* "," newline* <ObjectField>)+> newline* => {
        let mut fields = vec![head];
        fields.extend(tail);
        fields
    },
};

// Object field: key: value or key (shorthand)
ObjectField: ObjectField<'input> = {
    // Full form: key: value (allows keywords as keys)
    <key:ObjectKey> ":" <value:Expr> => ObjectField { key, value: Some(value) },
    // Shorthand form: key (means key: key) - only identifiers allowed, not keywords
    <key:identifier> => ObjectField { key, value: None },
};

// ===== Prompt Expressions (Milestone 5) =====

// Think expression: think { ... }
// Note: think { } || ask { } is just a binary || expression, not special syntax
ThinkExpr: Expr<'input> = {
    "think" "{" <content:PromptBlock> "}" => Expr::Think(content),
};

// Ask expression: ask { ... }
AskExpr: Expr<'input> = {
    "ask" "{" <content:PromptBlock> "}" => Expr::Ask(content),
};

// Do expression: do { ... }
// Note: Lexer emits Do token only inside prompt blocks
// Outside prompts, "do" is just an identifier
// We'll handle both cases by also checking for identifier "do"
DoExpr: Expr<'input> = {
    // Inside prompt context - lexer emits Do token
    "do" "{" <statements:StatementList> "}" => Expr::Do(Block { statements }),
};

// Prompt block - mixture of text and embedded do blocks
// Note: Lexer produces multiple prompt_text tokens (one per word) plus newlines
// We collect them all, and newlines are allowed anywhere
PromptBlock: PromptBlock<'input> = {
    <items:(PromptItemOrNewline)*> => {
        // Filter out None (newlines) and merge adjacent Text nodes
        let filtered: Vec<PromptItem> = items.into_iter().filter_map(|x| x).collect();
        let mut merged = Vec::new();
        let mut text_acc: Vec<&str> = Vec::new();

        for item in filtered {
            match item {
                PromptItem::Text(t) => {
                    // Accumulate text nodes
                    text_acc.push(t);
                },
                other => {
                    // Flush accumulated text if any
                    if !text_acc.is_empty() {
                        let combined = text_acc.join(" ");
                        merged.push(PromptItem::Text(combined.leak()));
                        text_acc.clear();
                    }
                    merged.push(other);
                }
            }
        }

        // Flush any remaining accumulated text
        if !text_acc.is_empty() {
            let combined = text_acc.join(" ");
            merged.push(PromptItem::Text(combined.leak()));
        }

        PromptBlock { items: merged }
    },
};

// Either a prompt item or a newline (which we'll filter out)
PromptItemOrNewline: Option<PromptItem<'input>> = {
    <item:PromptItem> => Some(item),
    newline => None,
};

// Individual prompt item - either text or embedded code
PromptItem: PromptItem<'input> = {
    // Raw prompt text
    <text:prompt_text> => PromptItem::Text(text),

    // Escaped character: $'<char>' - treated as literal text
    <escaped:prompt_escape> => PromptItem::Text(escaped),

    // Balanced braces (treated as literal text in the prompt)
    "{" <inner:PromptBlock> "}" => {
        // Build text representation: "{" + inner items + "}"
        let mut text = String::from("{");
        for item in &inner.items {
            match item {
                PromptItem::Text(s) => text.push_str(s),
                PromptItem::Interpolation(expr) => {
                    // This shouldn't happen in balanced braces, but handle it
                    text.push_str(&format!("${{{:?}}}", expr));
                },
                PromptItem::Code(block) => {
                    // This shouldn't happen in balanced braces, but handle it
                    text.push_str(&format!("do {{{:?}}}", block));
                },
            }
        }
        text.push('}');
        PromptItem::Text(text.leak())
    },

    // Variable interpolation: $identifier or ${expr}
    dollar <id:identifier> => PromptItem::Interpolation(Expr::Identifier(id)),
    dollar "{" <e:Expr> "}" => PromptItem::Interpolation(e),

    // Do-block or standalone "do" - handle both cases
    DoOrText,
};

// Helper to handle "do" keyword - either a do-block or standalone text
// Using error recovery to handle standalone "do" that's not followed by "{"
DoOrText: PromptItem<'input> = {
    // Try to match do-block first
    "do" "{" <statements:StatementList> "}" => PromptItem::Code(Block { statements }),

    // If that fails (do not followed by {), treat "do" as text
    // We use an error production to catch this case
    ! => {
        // This error production catches parse errors in DoOrText
        // If we see "do" but it's not followed by "{", treat it as text
        PromptItem::Text("do")
    },
};
