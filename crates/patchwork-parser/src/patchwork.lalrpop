// Patchwork grammar - Milestone 2: Top-level items and block structure

use crate::token::ParserToken;
use crate::adapter::ParseError;
use crate::ast::*;

grammar<'input>(input: &'input str);

// External token definition - we use our custom lexer
extern {
    type Location = usize;
    type Error = ParseError;

    enum ParserToken<'input> {
        // Whitespace
        whitespace => ParserToken::Whitespace(<&'input str>),
        newline => ParserToken::Newline(<&'input str>),

        // String literals
        string_start => ParserToken::StringStart,
        string_end => ParserToken::StringEnd,
        string_text => ParserToken::StringText(<&'input str>),
        single_quote_string => ParserToken::SingleQuoteString(<&'input str>),
        dollar => ParserToken::Dollar,

        // Prompt operators
        "think" => ParserToken::Think,
        "ask" => ParserToken::Ask,
        "do" => ParserToken::Do,

        // Keywords
        "import" => ParserToken::Import,
        "from" => ParserToken::From,
        "var" => ParserToken::Var,
        "if" => ParserToken::If,
        "else" => ParserToken::Else,
        "for" => ParserToken::For,
        "while" => ParserToken::While,
        "await" => ParserToken::Await,
        "task" => ParserToken::Task,
        "skill" => ParserToken::Skill,
        "fun" => ParserToken::Fun,
        "type" => ParserToken::Type,
        "return" => ParserToken::Return,
        "succeed" => ParserToken::Succeed,
        "fail" => ParserToken::Fail,
        "break" => ParserToken::Break,
        "self" => ParserToken::SelfKw,
        "in" => ParserToken::In,

        // Literals
        "true" => ParserToken::True,
        "false" => ParserToken::False,
        number => ParserToken::Number(<&'input str>),
        identifier => ParserToken::Identifier(<&'input str>),

        // Multi-character operators
        "..." => ParserToken::Ellipsis,
        "->" => ParserToken::Arrow,
        "==" => ParserToken::Eq,
        "!=" => ParserToken::Neq,
        "<=" => ParserToken::Lte,
        ">=" => ParserToken::Gte,
        "&&" => ParserToken::AndAnd,
        "||" => ParserToken::OrOr,

        // Punctuation
        "{" => ParserToken::LBrace,
        "}" => ParserToken::RBrace,
        "(" => ParserToken::LParen,
        ")" => ParserToken::RParen,
        "[" => ParserToken::LBracket,
        "]" => ParserToken::RBracket,
        ";" => ParserToken::Semicolon,
        "," => ParserToken::Comma,
        ":" => ParserToken::Colon,
        "@" => ParserToken::At,

        // Single-character operators
        "<" => ParserToken::Lt,
        ">" => ParserToken::Gt,
        "+" => ParserToken::Plus,
        "-" => ParserToken::Minus,
        "*" => ParserToken::Star,
        "/" => ParserToken::Slash,
        "%" => ParserToken::Percent,
        "!" => ParserToken::Bang,
        "=" => ParserToken::Assign,
        "|" => ParserToken::Pipe,
        "&" => ParserToken::Ampersand,
        "." => ParserToken::Dot,

        // Prompt text
        prompt_text => ParserToken::PromptText(<&'input str>),

        // Comments
        comment => ParserToken::Comment(<&'input str>),

        // Special
        end => ParserToken::End,
    }
}

// ====================
// Grammar Rules
// ====================

// Program: top-level items (with optional newlines between them - similar to StatementList)
pub Program: Program<'input> = {
    newline* <head:Item> <tail:(newline+ <Item>)*> newline* end => {
        let mut items = vec![head];
        items.extend(tail);  // lalrpop flattens (newline+ <Item>) to just Item
        Program { items }
    },
    newline* end => Program { items: vec![] },  // Empty program
};

// Top-level item
Item: Item<'input> = {
    <ImportDecl> => Item::Import(<>),
    <SkillDecl> => Item::Skill(<>),
    <TaskDecl> => Item::Task(<>),
    <FunctionDecl> => Item::Function(<>),
};

// Import declaration: `import path` or `import ./{a, b, c}`
ImportDecl: ImportDecl<'input> = {
    "import" <path:ImportPath> => ImportDecl { path },
};

// Import path
ImportPath: ImportPath<'input> = {
    // Relative multi-import: ./{analyst, narrator, scribe}
    "." "/" "{" <head:identifier> <tail:("," <identifier>)*> "}" => {
        let mut names = vec![head];
        names.extend(tail);
        ImportPath::RelativeMulti(names)
    },
    // Simple dotted path: For now, just accept identifier sequences
    // Will expand this in later milestones if needed
    <id:identifier> => ImportPath::Simple(vec![id]),
};

// Skill declaration: skill name(params) { body }
SkillDecl: SkillDecl<'input> = {
    "skill" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        SkillDecl { name, params, body }
    },
};

// Task declaration: task name(params) { body }
TaskDecl: TaskDecl<'input> = {
    "task" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        TaskDecl { name, params, body }
    },
};

// Function declaration: fun name(params) { body }
FunctionDecl: FunctionDecl<'input> = {
    "fun" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        FunctionDecl { name, params, body }
    },
};

// Parameter list (comma-separated identifiers)
ParamList: Vec<Param<'input>> = {
    // Empty list
    => vec![],
    // Single param
    <head:identifier> => vec![Param { name: head }],
    // Multiple params
    <head:identifier> <tail:("," <identifier>)+> => {
        let mut params = vec![Param { name: head }];
        for name in tail {
            params.push(Param { name });
        }
        params
    },
};

// Block: { statements }
// Statements are separated by newlines or semicolons (Swift-style)
Block: Block<'input> = {
    "{" <statements:StatementList> "}" => Block { statements },
};

// Separator: newline or semicolon (at least one required between statements)
Separator: () = {
    newline => (),
    ";" => (),
};

// Statement list
// Key insight from Swift: newlines (or semicolons) SEPARATE statements.
// This means after "return", if there's a newline, we know return has no value.
// If there's no newline, the expression continues on the same logical line.
StatementList: Vec<Statement<'input>> = {
    // Empty block (allow leading/trailing newlines)
    newline* => vec![],

    // Non-empty: optional leading newlines, then statements separated by newlines/semicolons
    newline* <head:Statement> <tail:(Separator+ <Statement>)*> Separator* => {
        let mut result = vec![head];
        result.extend(tail);
        result
    },
};

// Statement (Milestone 3: simple statements)
// Order matters for ambiguity resolution - more specific rules first
Statement: Statement<'input> = {
    // Control flow with blocks - unambiguous (blocks provide boundaries)
    <IfStmt>,
    <ForStmt>,
    <WhileStmt>,

    // Variable declarations - handled explicitly with all variants
    <VarDeclStmt>,

    // Keywords that can't start expressions - unambiguous
    <ReturnStmt>,
    <SucceedStmt>,
    <FailStmt>,
    <BreakStmt>,

    // Expression statement last (catch-all)
    <ExprStmt>,
};

// Variable declaration
// Reordered to try with = first (greedy matching for init)
VarDeclStmt: Statement<'input> = {
    // var x: type = expr (most specific - try first)
    "var" <name:identifier> ":" <type_ann:TypeExpr> "=" <init:Expr> => {
        Statement::VarDecl { name, type_ann: Some(type_ann), init: Some(init) }
    },
    // var x = expr (no type annotation)
    "var" <name:identifier> "=" <init:Expr> => {
        Statement::VarDecl { name, type_ann: None, init: Some(init) }
    },
    // var x: type (no init) - only matches if no = follows
    "var" <name:identifier> ":" <type_ann:TypeExpr> => {
        Statement::VarDecl { name, type_ann: Some(type_ann), init: None }
    },
    // var x (no init, no type)
    "var" <name:identifier> => {
        Statement::VarDecl { name, type_ann: None, init: None }
    },
};

// If statement (block provides clear termination)
IfStmt: Statement<'input> = {
    "if" <condition:Expr> <then_block:Block> <else_block:("else" <Block>)?> => {
        Statement::If { condition, then_block, else_block }
    },
};

// For loop (block provides clear termination)
ForStmt: Statement<'input> = {
    "for" "var" <var:identifier> "in" <iter:Expr> <body:Block> => {
        Statement::For { var, iter, body }
    },
};

// While loop (block provides clear termination)
WhileStmt: Statement<'input> = {
    "while" "(" <condition:Expr> ")" <body:Block> => {
        Statement::While { condition, body }
    },
};

// Return statement
// To resolve the ambiguity, we need to be explicit about when there's no expression.
// The parser sees "return" and doesn't know if what follows is:
// 1) part of an expression for this return
// 2) the start of the next statement
//
// Solution: Accept that statements in blocks don't need explicit terminators
// because blocks themselves provide boundaries. But we need to restrict what
// can be a statement-level expression vs a return expression.
//
// Simpler: just always try to parse an expression if possible (greedy matching)
// This rule says: ALWAYS try to match "return <Expr>" first due to ordering
ReturnStmt: Statement<'input> = {
    "return" <e:Expr?> => Statement::Return(e),
};

// Succeed/Fail/Break - these are unambiguous keywords
SucceedStmt: Statement<'input> = {
    "succeed" => Statement::Succeed,
};

FailStmt: Statement<'input> = {
    "fail" => Statement::Fail,
};

BreakStmt: Statement<'input> = {
    "break" => Statement::Break,
};

// Expression statement
ExprStmt: Statement<'input> = {
    <Expr> => Statement::Expr(<>),
};

// Type expression (Milestone 3: simple names only)
TypeExpr: TypeExpr<'input> = {
    <identifier> => TypeExpr::Name(<>),
};

// Expression (Milestone 3: minimal set - identifiers, literals)
Expr: Expr<'input> = {
    <identifier> => Expr::Identifier(<>),
    <number> => Expr::Number(<>),
    "true" => Expr::True,
    "false" => Expr::False,
};
