import ./{analyst, scribe}
import std.log

# Orchestrates the git commit rewrite process by executing the analyst's commit plan in
# coordination with the scribe.
#
# @arg session_id 
# @arg work_dir 
#
# @color orange
export default agent narrator(session_id, work_dir) {
    log("Waiting for commit plan from analyst")

    var {
        type: "commit_plan",
        branch: string,
        clean_branch: string,
        base_commit: string,
        timestamp: string,
        commits: [{num: number, description: string}]
    } = self.receive(10800000)

    log("Received commit plan: ${commits.length} commits")

    var i = 0;

    for var commit in commits {
        scribe.send({
            session: session_id,
            message: {
                commit_num: commit.num,
                description: commit.description
            }
        })

        log("Requested commit ${i}: Add user authentication models")

        type scribe_result = {
            status: "success" | "error",
            commit_hash: string,
            description: string,
            files_changed: [string]
        }

        var result: scribe_result  = self.receive(10800000)

        if status = "error" {
            var description = think { Scribe returned ${scribe_result}. Explain what went wrong }
            narrator.send({ status, error: description })
            throw "Scribe failed"
        }
        i++
    }

    validate_trees(work_dir, branch, clean_branch)

    cat({
        session_id,
        timestamp,
        original_branch: branch,
        clean_branch,
        base_commit,
        work_dir,
        commits_created: i
    }) > "${work_dir}/state.json"

    scribe.send(session_id, {
        type: "done"
    })

    $ echo "done" > "${work_dir}/narrator/status"

    log("Complete! Created ${i} commits")
}

fun validate_trees(work_dir, branch, clean_branch) {
    # Compare tree hashes
    $ git checkout "${clean_branch}"
    var clean_tree = $(git rev-parse HEAD^{tree}) # FIXME: what is {tree} here?

    $ git checkout "${branch}"
    var original_tree = $(git rev-parse HEAD^{tree})

    if clean_tree = original_tree {
          log("Validation successful - trees match")
          return
    }

    log("Trees don't match, applying remaining changes")
    # Switch back to clean branch
    $ git checkout "${clean_branch}"

    # Get the diff of what's missing
    $ git diff HEAD "${branch}" > "${work_dir}/remaining.diff"

    # Log what we're adding (with details)
    var remaining_diff=$(cat "${work_dir}/remaining.diff")

    log("Remaining diff", remaining_diff)

    # Apply the remaining changes
    $ git apply "${work_dir}/remaining.diff"

    # Amend the last commit with the missing changes
    $ git commit --amend --no-edit

    log("Amended last commit with remaining changes")
}
