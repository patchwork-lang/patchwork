# Checkpoint: M10 Bare Commands - IdentifierCall Token Implementation

**Session Focus:** Implemented lexer-level disambiguation for function calls vs bare commands using IdentifierCall token

## Key Accomplishments

### Disambiguation Token Design
Successfully solved the whitespace-sensitivity challenge by adding `IdentifierCall` lexer token:
- Matches `identifier(` with no space (e.g., `test(`)
- Placed before `Identifier` rule in lexer.alex for priority
- Parser adapter strips trailing `(` to extract clean identifier name
- Enables grammar to distinguish: `f(x)` (function call) from `f x` (bare command)

### Lexer Changes
```alex
IdentifierCall: <Code> {{ID}}\(  # Before Identifier rule
Identifier: <Code> {{ID}}
```

### Parser Updates
- Added `IdentifierOrCall` helper rule accepting both token types
- Updated declarations (SkillDecl, TaskDecl, FunctionDecl) to use `IdentifierOrCall` with optional `(`
- Modified PostfixExpr to handle function calls via `identifier_call`:
  - `identifier_call ExprList ")"` - direct function call
  - `PostfixExpr "." identifier_call ExprList ")"` - method call

### AST Extensions
```rust
CommandArg: Literal(&str) | String(StringLiteral)
RedirectOp: Out | Append | ErrOut | ErrToOut
Expr::BareCommand { name, args }
Expr::CommandSubst { name, args }
```

## Test Results
✅ All 88 existing parser tests passing
✅ Zero lalrpop conflicts maintained
✅ Clean separation: identifier_call = function, identifier = potential bare command

## Design Decisions

**Why IdentifierCall over SPACED_LPAREN:**
- Cleaner: makes function call case explicit rather than exceptional
- Simpler: no need to preserve whitespace tokens in specific contexts
- Scales: works naturally with existing whitespace filtering

**Grammar Strategy:**
- Accept both patterns in declarations via `IdentifierOrCall` helper
- Function calls exclusively via `identifier_call` in expressions
- Regular `identifier` tokens now available for bare command detection

## Next Phase

Ready to implement bare command grammar rules:
1. Recognize `identifier` followed by arguments (not `identifier_call`)
2. Parse command arguments as literals or strings
3. Handle operators (+, -, etc.) as part of argument text
4. Add command substitution variant to string interpolation
5. Implement redirection operators

**Foundation solid** - can now build bare command parsing without conflicts