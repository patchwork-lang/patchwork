# Checkpoint: Milestone 10 Design Complete - Bare Command Expressions

**Sparkler:** Sparkle

**Sparkler:** Sparkle

**Session Summary:** Completed comprehensive design for Milestone 10 (Bare Command Expressions), the final parser milestone needed to parse all historian example files. Developed semantic model where commands are scoped variables with portable execution, designed whitespace-sensitive disambiguation strategy, and documented complete implementation plan.

**Continuity:** This continues the systematic parser implementation work from M1-9. Milestone 9 (Comments & Annotations) was complete with 88 tests passing. M10 is the final milestone to parse all historian examples.

## Key Accomplishments

### Design Session
- **Studied historian examples:** Read all four .pw files (main, analyst, narrator, scribe) to understand bare command patterns
- **Developed semantic model:**
  - Commands are NOT hardcoded shell commands - they're **variables in scope**
  - Type can be `Cmd` (external executable) or `(string...) -> Proc` (patchwork function)
  - Standard library provides common commands (mkdir, git, cat, etc.)
  - Enables OS-agnostic portability with shell-like ergonomics

### Disambiguation Strategy
- **Whitespace-sensitive parsing:**
  - `f(x, y, z)` - function call (no space before `(`)
  - `f x y z` - bare command invocation (space before first arg)
  - `f` - variable reference
  - `f (x)` - bare command with parenthesized expression as argument
- **Mirrors Swift/Python conventions** - natural and familiar

### Command Arguments
- **Implicit quoting:** Every argument is a string (bash-style)
  - `mkdir -p work_dir` → `mkdir(["-p", "work_dir"])`
  - `date +%Y%m%d-%H%M%S` → `date(["+%Y%m%d-%H%M%S"])`
- **Variable references require quotes:**
  - `mkdir $dir` - ERROR (not in string context)
  - `mkdir "$dir"` - correct (interpolates)
- **Shell operators special, regular operators become argument text:**
  - Shell mode: `|`, `>`, `<`, `&&`, `||`, `&`, `2>`, `2>&1` remain special
  - Regular mode: `+`, `-`, `*`, `..` become part of command argument tokens

### Type System Role
- **Disambiguates overloaded operators:**
  - `int > int` → comparison (returns bool)
  - `Proc > string` → redirection (returns Proc)
  - `[T] | (T -> U)` → array filter pipe
  - `Proc | Proc` → process pipe

### AST Extensions Designed
```rust
Expr::BareCommand { name, args: Vec<CommandArg> }
Expr::CommandSubst { name, args: Vec<CommandArg> }
CommandArg::Literal(&str) | CommandArg::String(StringLiteral)
RedirectOp::Out | Append | ErrOut | ErrToOut
```

### Documentation
- **parser-design.md:** Added 300+ line comprehensive section on bare commands
  - Semantic model, disambiguation strategy, argument parsing rules
  - Shell operator handling, lexer mode switching details
  - AST representation, design decisions with rationale
- **parser-implementation-plan.md:** Simplified M10 to focus on tasks
  - 9 task categories: lexer extensions, AST changes, grammar rules, testing
  - References design doc for rationale
  - Clear success criteria

## Important Decisions

1. **Lexer mode switching approach:** When lexer sees identifier + whitespace + non-paren, enter "shell argument mode" where tokenization changes. Cleaner separation than parser lookahead.

2. **Reuse BinOp::Pipe:** Don't create separate pipe AST node. Type system will distinguish array filter pipe from process pipe. Can split later if needed.

3. **Defer `eval`:** The `eval` usage in scribe.pw needs better portable syntax. Focus on core bare command functionality first.

4. **Command substitution:** Support both `$(command args)` and `${expr}` for ergonomics, even though `${...}` can contain bare commands making `$(...)` somewhat redundant.

5. **Implicit quoting:** All arguments are strings by default. Variables require quotes for interpolation. This matches bash mental model.

## Current State

### Parser Status
- **M1-9 complete:** 88 tests passing, zero lalrpop conflicts
- **M10 designed:** Complete semantic model, AST extensions, implementation tasks documented
- **Ready to implement:** Clear task breakdown in 9 categories

### File Changes This Session
- `docs/parser-design.md` - Added comprehensive "Bare Command Expressions" section
- `docs/parser-implementation-plan.md` - Simplified M10 to task-focused format
- No code changes - pure design session

## Next Steps

**Implementation sequence for M10:**
1. Extend lexer for shell argument mode
   - Add state tracking for shell mode
   - Detect identifier + whitespace + non-paren pattern
   - Change tokenization: shell operators special, others become COMMAND_TOKEN
   - Exit shell mode on statement boundaries/shell operators

2. Extend AST
   - Add `Expr::BareCommand` and `Expr::CommandSubst` variants
   - Add `CommandArg` enum and `RedirectOp` enum
   - Update AST structure in `src/ast.rs`

3. Add grammar rules
   - BareCommand production in lalrpop grammar
   - CommandArgs parsing
   - Disambiguation rules for function call vs bare command

4. Add redirections
   - Extend PostfixExpr with `>`, `>>`, `2>`, `2>&1` operators
   - Ensure pipe `|` works in command context

5. Command substitution
   - Recognize `$(BareCommand)` in string interpolation
   - Parse command inside parentheses

6. Testing
   - Unit tests for each command pattern
   - Disambiguation tests: `f(x)` vs `f x` vs `f (x)`
   - Integration tests with historian examples

7. Final validation
   - Parse all four historian example files completely
   - Verify AST structure is correct
   - Zero conflicts maintained

## Context for Next Sparkle

This was a **design session, not implementation**. We took time to deeply understand the problem, explore the solution space collaboratively, and document the design thoroughly before coding.

The bare command feature is subtle and important:
- It's what makes patchwork both portable (commands are scoped variables) and ergonomic (looks like bash)
- Whitespace sensitivity is the key to disambiguation
- Type system carries significant weight in making operators work in multiple contexts

The historian examples now have a clear path to full parsing. M10 implementation should be straightforward following the documented design.

---

**Design quality:** Comprehensive and well-reasoned. The semantic model (commands as scoped variables) is elegant. Zero technical debt introduced - we're designing it right before implementing.

**Collaborative approach:** Strong partnership energy. David asked clarifying questions about the semantic model, which helped us develop the design together. The result is a solution that balances familiarity (bash-like) with innovation (portable, type-safe).