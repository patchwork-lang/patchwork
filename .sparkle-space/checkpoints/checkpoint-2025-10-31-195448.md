# Checkpoint: Patchwork Lexer Design

## Project Context

**Patchwork** is David's experimental hybrid programming language combining deterministic code (for control flow/logic) with AI prompting (for flexible/adaptive tasks). The inspiration comes from his blog post about the historian project - an experiment that showed LLMs can support powerful abstractions but prompting fails for deterministic control flow.

**Key insight:** Let traditional code handle loops/conditionals, let AI handle creative/adaptive work.

## Workspace: /Users/dherman/Code/patchwork

**What exists:**
- `examples/historian/` - Hand-written patchwork port of the git history rewriting tool (4 .pw files: main, analyst, narrator, scribe)
- `Cargo.toml` - Workspace manifest
- `crates/patchwork-lexer/` - Empty crate (just cargo template) using parlex-gen
- `docs/lexer-design.md` - Lexer design document (created this session)

## Session Achievements

1. **Explored patchwork syntax** - Agent searched examples/historian and found:
   - `think { prompt }` and `ask { prompt }` for LLM reasoning/user interaction
   - `do { code }` to return to code context from prompts
   - Arbitrary nesting: `think { ... do { ... think { ... } } }`
   - Rich code syntax: imports, var declarations, bash substitution `$(...)`, string interpolation `${...}`, control flow, async/await, inter-task messaging

2. **Researched lexer tooling** - Discovered parlex-gen's ALEX specification format:
   - Supports multiple lexical states for context-aware tokenization
   - Build-time code generation via build.rs
   - State transition rules with lookahead

3. **Created lexer design** - Key decisions documented in `docs/lexer-design.md`:
   - Two states: **Code** (default) and **Prompt**
   - State stack + brace depth tracking for nesting
   - **PromptText** as single token initially (refinement later if needed)
   - Code tokens tailored to historian example (not full JS/bash grammar)
   - **Critical:** `do` only triggers transition in Prompt state when followed by `{` (with optional whitespace)
   - Minimal validation in lexer (leave to parser)

## Next Steps

The next Sparkle should:
1. Implement ALEX specification based on design doc
2. Create build.rs to invoke parlex-gen
3. Test lexer on examples/historian/*.pw files
4. Iterate based on edge cases and parsing needs

## Collaboration Notes

David prefers:
- Informal communication
- Focused, practical designs (not over-engineering)
- Clear constraints upfront (single token for prompts, do { lookahead, minimal validation)
- Working with concrete examples (the historian port)

The collaboration has been efficient - David provided clear context, concrete artifacts, and crisp decisions when asked. The design doc balances current needs with future refinement notes.
