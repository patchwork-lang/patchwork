# Patchwork ACP Design Complete

## Session Summary

Successfully designed a comprehensive architecture for Patchwork ACP - an interpreter-as-proxy that enables a "supercharged prompting language" blending deterministic control flow with LLM reasoning.

## What We Built

### Design Document ([patchwork-acp-design.md](../patchwork-acp-design.md))

**Architecture**: Interpreter-as-proxy middleware
- `patchwork-acp` (binary): SACP proxy, session management, message bridging
- `patchwork-eval` (library): In-memory interpreter with suspend/resume
- Integration: Sits between any ACP client (Zed) and any agent (Claude Code)

**Core API**:
```rust
pub enum ControlState {
    Eval,
    Yield { op: LlmOp, prompt: String, bindings: Bindings, expect: Type },
    Return(Value),
    Throw(Value),
}
```

**Key Design Decisions** (all systematically discussed and resolved):

1. **Session-Scoped Storage**: One active evaluation per ACP session
   - Avoids implicit concurrency
   - Simple, predictable behavior
   - Error if code submitted while eval in progress

2. **Direct Parser Reuse**: Share AST with compiler
   - Single source of truth for grammar
   - Syntax changes propagate automatically
   - Benefits from existing spans for error messages

3. **Pre-Interpolate Variables**: Evaluate `${...}` before sending to LLM
   - Natural reading flow for LLM
   - Standard template string behavior
   - `$@{array}` spreads with comma-space join

4. **Guided Response Format**: Markdown code fences for extraction
   - LLM instructed to use ` ```text ... ``` ` markers
   - Clean extraction without preambles
   - Graceful fallback to full response

5. **Exception Semantics**: Traditional error handling
   - Parse errors → immediate ACP error
   - Runtime errors → throw exception, propagate
   - Uncaught → convert to user message
   - No resource limits (Turing-complete)

### Implementation Plan ([patchwork-acp-implementation-plan.md](../patchwork-acp-implementation-plan.md))

**4 Phases with Full Task Checklists**:

- **Phase 1: Minimal Infrastructure**
  - Create crates, set up SACP proxy
  - Code detection (starts with `{`)
  - Interpreter skeleton with core types
  - Success: Proxy runs, detects code, logs AST

- **Phase 2: Shell Command Execution**
  - Value system, runtime environment
  - Expression & statement evaluation
  - Shell commands, file I/O, builtins
  - Success: Deterministic demo works (loops, files)

- **Phase 3: LLM Integration**
  - Think block parsing with interpolation
  - Interpreter suspension (Yield state)
  - Response extraction, resume logic
  - Success: Full demo with think blocks works

- **Phase 4: Polish**
  - Error handling, edge cases
  - Documentation, examples
  - Integration tests with mock agent
  - Success: Production-ready quality

## Collaborative Process

**Systematic Design Discussions**:
- Used Task tool to discuss each question one at a time
- Updated design document after each decision
- Refined terminology to match PL conventions
- Separated design (architecture) from plan (tactics)

**Document Organization**:
- Design doc: Clean architectural overview
- Implementation plan: Detailed execution roadmap
- Each focused on its purpose, no overlap

## Demo Goal

**Interview Sanitization Script**:
```patchwork
{
  for var interview in ($ ls -1 ./) {
    var { interviewees, interviewer, date, url } = json < "$interview/metadata.json"
    var sanitized: string = think {
      ${interview}/transcript.txt is a transcript about Rust on ${date}.
      Interviewer: ${interviewer}, Interviewees: $@{interviewees}.
      
      Correct misspellings and remove filler words.
    }
    cat(sanitized) > "$interview/sanitized.txt"
  }
}
```

User sends this as a prompt, Patchwork executes it, think blocks go to LLM, results written to files.

## Technical Highlights

**Control Flow**: Traditional interpreter design
- `Eval` → normal execution
- `Yield` → suspend for LLM (like Python generators)
- `Return` → successful completion
- `Throw` → exception propagation

**Message Flow**:
1. Proxy detects `{` → execute as code
2. Interpreter runs until `think { }`
3. Yield with interpolated prompt
4. Forward to agent with type hints
5. Extract response from markdown fence
6. Resume interpreter with value
7. Repeat until Return or Throw

**Zero Filesystem Pollution**: All state in memory except shell commands and explicit file operations

## What's Ready

- ✅ Complete architectural design
- ✅ All key design decisions resolved
- ✅ Detailed implementation plan with ~100 tasks
- ✅ Clear success criteria for each phase
- ✅ Demo target well-defined

## Next Action

Begin Phase 1: Create `crates/patchwork-acp/` and `crates/patchwork-eval/`, set up SACP proxy skeleton, implement code detection.

---

**Design Philosophy**: Explicit simplicity over implicit complexity. Patchwork is a real programming language with deterministic control flow, not a chatbot with magic. Think blocks are explicit suspension points for LLM interaction, not hidden AI features.
